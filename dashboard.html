<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Study Space - Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <style>
        /* --- basic style --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; color: white; margin-bottom: 30px; }
        h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .subtitle { font-size: 1.1em; opacity: 0.9; }

        /* --- status bar & cards --- */
        .status-bar {
            background: white; padding: 15px 25px; border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 25px;
            display: flex; justify-content: space-between; align-items: center;
            flex-wrap: wrap; gap: 15px;
        }
        .status-item { display: flex; align-items: center; gap: 10px; }
        .status-dot { width: 12px; height: 12px; border-radius: 50%; animation: pulse 2s infinite; }
        .status-dot.online { background: #4CAF50; }
        .status-dot.offline { background: #f44336; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        .dashboard {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px; margin-bottom: 25px;
        }
        .card {
            background: white; border-radius: 15px; padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.3s, box-shadow 0.3s;
        }
        .card:hover { transform: translateY(-5px); box-shadow: 0 8px 12px rgba(0,0,0,0.15); }
        .card-header {
            display: flex; align-items: center; gap: 12px;
            margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #f0f0f0;
        }
        .card-icon {
            width: 50px; height: 50px; border-radius: 12px;
            display: flex; align-items: center; justify-content: center; font-size: 24px;
        }
        .card-title { font-size: 1.3em; font-weight: 600; color: #333; }
        .metric-value { font-size: 3em; font-weight: bold; text-align: center; margin: 20px 0; line-height: 1; }
        .metric-unit { font-size: 0.4em; color: #666; font-weight: normal; }
        .metric-caption { text-align: center; color: #666; font-size: 0.95em; margin-top: 10px; margin-bottom: 15px; }

        .signal-quality {
            display: flex; justify-content: space-around; margin-top: 20px;
            padding-top: 20px; border-top: 1px solid #eee;
        }
        .quality-item { text-align: center; }
        .quality-label { font-size: 0.85em; color: #666; margin-bottom: 5px; }
        .quality-value { font-size: 1.3em; font-weight: bold; }

        /* --- suggestion card style --- */
        .suggestion-box {
            grid-column: 1 / -1;
            display: flex; align-items: center; justify-content: center;
            padding: 20px; border-radius: 15px; text-align: center;
            transition: all 0.5s ease; border: 2px solid transparent;
        }
        .suggestion-icon { font-size: 2.5em; margin-right: 20px; }
        .suggestion-content h3 { font-size: 1.4em; margin-bottom: 5px; color: #333; }
        .suggestion-content p { font-size: 1.1em; color: #666; }

        /* --- chart box --- */
        .chart-container {
            grid-column: 1 / -1; background: white; border-radius: 15px;
            padding: 25px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 25px;
        }
        .chart-wrapper { position: relative; height: 300px; }

        /* --- historical analysis --- */
        .analysis-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;
        }
        .analysis-title { font-size: 1.2em; font-weight: 600; margin-bottom: 15px; }
        .analysis-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;
        }
        .analysis-box {
            background: rgba(255, 255, 255, 0.2); padding: 15px;
            border-radius: 8px; backdrop-filter: blur(10px);
        }
        .analysis-box-label { font-size: 0.9em; opacity: 0.9; margin-bottom: 8px; }
        .analysis-box-value { font-size: 2em; font-weight: bold; }

        /* --- status history style --- */
        .history-table-wrapper { overflow-x: auto; }
        .history-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .history-table th, .history-table td {
            padding: 15px; text-align: center; border-bottom: 1px solid #eee; vertical-align: middle;
        }
        .history-table th {
            background-color: #f8f9fa; color: #666; font-weight: 600;
            text-transform: uppercase; font-size: 0.85em; letter-spacing: 0.5px;
        }
        .history-table tr:last-child td { border-bottom: none; }

        .status-badge {
            display: inline-flex; align-items: center; justify-content: center;
            padding: 8px 16px; border-radius: 20px;
            font-size: 0.9em; font-weight: 600; color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 130px;
        }
        .empty-slot { color: #ccc; font-weight: bold; font-size: 1.2em; }

        .legend-container {
            display: flex; justify-content: center; gap: 30px; flex-wrap: wrap;
            margin-top: 0; padding-top: 20px; border-top: 1px solid #eee;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.95em; color: #555; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }

        .status-message {
            padding: 15px; border-radius: 10px; margin-top: 15px;
            font-size: 0.95em; display: flex; align-items: center; gap: 10px;
        }
        .status-message.info { background: #e3f2fd; color: #1976d2; }
        .status-message.success { background: #e8f5e9; color: #388e3c; }
        .status-message.warning { background: #fff3e0; color: #f57c00; }
        .status-message.error { background: #ffebee; color: #d32f2f; }

        footer { text-align: center; color: white; margin-top: 30px; opacity: 0.8; }

        /* ========== Prediction Module Styles ========== */
        #predictionContainer {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .prediction-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 20px;
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .prediction-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.2);
        }

        .prediction-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
        }

        .prediction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        }

        .prediction-rank {
            font-size: 0.9em;
            font-weight: 600;
            opacity: 0.9;
            letter-spacing: 0.5px;
        }

        .prediction-quality {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .prediction-quality.quality-high { background: rgba(76, 175, 80, 0.3); }
        .prediction-quality.quality-medium { background: rgba(255, 193, 7, 0.3); }
        .prediction-quality.quality-low { background: rgba(244, 67, 54, 0.3); }

        .prediction-time-display {
            text-align: center;
            margin: 20px 0;
        }

        .time-value {
            font-size: 2em;
            font-weight: bold;
            line-height: 1;
            margin-bottom: 5px;
        }

        .time-date {
            font-size: 1em;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .time-relative {
            font-size: 0.85em;
            opacity: 0.8;
            font-style: italic;
        }

        .prediction-metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
            padding: 15px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        }

        .metric-cell { text-align: center; }

        .metric-label {
            display: block;
            font-size: 0.75em;
            color: white !important;
            opacity: 0.9;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .metric-value {
            display: block;
            font-size: 1.8em;
            font-weight: bold;
            line-height: 1;
        }

        .prediction-expected {
            margin-top: 15px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .expected-title {
            font-size: 0.85em;
            opacity: 0.9;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .expected-values {
            font-size: 0.9em;
            opacity: 0.95;
        }

        .prediction-message {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            padding: 20px;
            border-radius: 10px;
            margin: 10px 0;
        }

        .prediction-message.info {
            background: #e3f2fd;
            color: #1976d2;
            border-left: 4px solid #1976d2;
        }

        .prediction-message.error {
            background: #ffebee;
            color: #d32f2f;
            border-left: 4px solid #d32f2f;
        }

        .message-icon {
            flex-shrink: 0;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.75em;
            letter-spacing: 1px;
        }

        .prediction-message.info .message-icon { background: rgba(25, 118, 210, 0.2); }
        .prediction-message.error .message-icon { background: rgba(211, 47, 47, 0.2); }

        .message-content { flex: 1; }

        .message-content strong {
            display: block;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .message-content p {
            margin: 8px 0;
            line-height: 1.5;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 12px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #1976d2, #42a5f5);
            transition: width 0.5s ease;
        }

        .progress-note {
            font-size: 0.9em;
            font-style: italic;
            opacity: 0.8;
            margin-top: 8px;
        }

        #predictionMetadata {
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            margin-top: 20px;
        }

        .metadata-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .metadata-label {
            font-size: 0.85em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metadata-value {
            font-size: 1.1em;
            font-weight: 600;
            color: #333;
        }

        @media (max-width: 768px) {
            .dashboard { grid-template-columns: 1fr; }
            h1 { font-size: 2em; }
            .status-bar { flex-direction: column; gap: 10px; }
            .suggestion-box { flex-direction: column; text-align: center; }
            .suggestion-icon { margin-right: 0; margin-bottom: 10px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Smart Study Space Monitor</h1>
            <div class="subtitle">IoT Dashboard with Real-time Analytics</div>
        </header>

        <div class="status-bar">
            <div class="status-item">
                <div class="status-dot" id="connectionStatus"></div>
                <span id="connectionText">Connecting...</span>
            </div>
            <div class="status-item">
                <strong>System Status:</strong>
                <span id="systemStatus">READY</span>
            </div>
            <div class="status-item">
                <strong>Records:</strong>
                <span id="recordCount">0</span>
            </div>
            <div class="status-item">
                <strong>Last Update:</strong>
                <span id="lastUpdate">--:--:--</span>
            </div>
        </div>

        <div class="dashboard">
            <div class="card">
                <div class="card-header">
                    <div class="card-icon" style="background: #e3f2fd;">
                        <span style="color: #1976d2;">üîä</span>
                    </div>
                    <div class="card-title">Ambient Noise</div>
                </div>
                <div class="metric-value" id="noiseValue" style="color: #4CAF50; font-size: 2.2em;">-- <span class="metric-unit">dB</span></div>
                <div class="metric-caption">Sound Level</div>
                <div class="signal-quality">
                    <div class="quality-item">
                        <div class="quality-label">Peak-to-Peak</div>
                        <div class="quality-value" id="p2pValue">--</div>
                    </div>
                    <div class="quality-item">
                        <div class="quality-label">Environment</div>
                        <div class="quality-value" id="noiseLevel">--</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-icon" style="background: #fce4ec;">
                        <span style="color: #c2185b;">‚ù§Ô∏è</span>
                    </div>
                    <div class="card-title">Heart Rate</div>
                </div>
                <div class="metric-value" id="bpmValue" style="color: #e91e63; font-size: 2.2em;">-- <span class="metric-unit">BPM</span></div>
                <div class="metric-caption">Avg Heart Rate</div>
                <div class="signal-quality">
                    <div class="quality-item">
                        <div class="quality-label">Beat Count</div>
                        <div class="quality-value" id="beatCount">0</div>
                    </div>
                    <div class="quality-item">
                        <div class="quality-label">Finger Status</div>
                        <div class="quality-value" id="fingerStatus">--</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-icon" style="background: #fff3e0;">
                        <span style="color: #f57c00;">üìä</span>
                    </div>
                    <div class="card-title">Status Assessment</div>
                </div>
                <div class="metric-value" id="overallState" style="color: #ff9800; font-size: 2.2em;">--</div>
                <div class="metric-caption">Current Status</div>
                <div class="signal-quality">
                    <div class="quality-item">
                        <div class="quality-label">Environment</div>
                        <div class="quality-value" id="envState">--</div>
                    </div>
                    <div class="quality-item">
                        <div class="quality-label">Mental State</div>
                        <div class="quality-value" id="mindState">--</div>
                    </div>
                </div>
                <div id="signalMessage" class="status-message info" style="display: none;">
                    <span>‚ÑπÔ∏è</span><span id="signalMessageText"></span>
                </div>
            </div>

            <div class="card suggestion-box" id="suggestionCard" style="background: #f8f9fa;">
                <div class="suggestion-icon" id="suggestionIcon">ü§ñ</div>
                <div class="suggestion-content">
                    <h3 id="suggestionTitle">System Ready</h3>
                    <p id="suggestionText">Waiting for sensor data to provide study suggestions...</p>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <div class="analysis-section">
                <div class="analysis-title">ThingSpeak Historical Analysis</div>
                <div class="analysis-grid">
                    <div class="analysis-box"><div class="analysis-box-label">Avg Noise</div><div class="analysis-box-value" id="avgNoise">--</div></div>
                    <div class="analysis-box"><div class="analysis-box-label">Avg BPM</div><div class="analysis-box-value" id="avgBPM">--</div></div>
                    <div class="analysis-box"><div class="analysis-box-label">BPM Range</div><div class="analysis-box-value" id="bpmRange">--</div></div>
                    <div class="analysis-box"><div class="analysis-box-label">Noisy %</div><div class="analysis-box-value" id="noisyPercent">--</div></div>
                    <div class="analysis-box"><div class="analysis-box-label">Data Points</div><div class="analysis-box-value" id="dataPoints">--</div></div>
                    <div class="analysis-box"><div class="analysis-box-label">Env Quality</div><div class="analysis-box-value" id="envQuality" style="font-size: 1.5em;">--</div></div>
                </div>
            </div>

            <h2 style="margin-bottom: 20px; color: #333;">Historical Trends (ThingSpeak)</h2>
            <div class="chart-wrapper">
                <canvas id="historyChart"></canvas>
            </div>
        </div>

        <div class="card" style="grid-column: 1 / -1; margin-bottom: 30px;">
            <div class="card-header">
                <div class="card-icon" style="background: #e8f5e9;">
                    <span style="color: #2e7d32;">üìÖ</span>
                </div>
                <div class="card-title">Status History</div>
            </div>

            <div class="history-table-wrapper">
                <table class="history-table">
                    <thead>
                        <tr>
                            <th style="width: 200px;">Time Slot (3H)</th>
                            <th id="date-header-0">Day Before</th>
                            <th id="date-header-1">Yesterday</th>
                            <th id="date-header-2" style="color: #667eea;">Today</th>
                        </tr>
                    </thead>
                    <tbody id="historyTableBody"></tbody>
                </table>
            </div>

            <div class="legend-container">
                <div class="legend-item"><div class="legend-dot" style="background: #4CAF50;"></div><span>Flow State (Optimal)</span></div>
                <div class="legend-item"><div class="legend-dot" style="background: #ff9800;"></div><span>Normal Learning</span></div>
                <div class="legend-item"><div class="legend-dot" style="background: #f44336;"></div><span>Distracted (Noisy)</span></div>
                <div class="legend-item"><div class="legend-dot" style="background: #9e9e9e;"></div><span>Standby / No Data</span></div>
            </div>
        </div>

         <!-- Prediction Section -->
        <div class="card" style="grid-column: 1 / -1; margin-bottom: 30px;">
            <div class="card-header">
                <div class="card-icon" style="background: linear-gradient(135deg, #667eea, #764ba2); font-size: 28px;">
                    &#128302;
                </div>
                <div style="flex: 1;">
                    <div class="card-title">Flow State Predictions</div>
                    <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                        AI-powered forecast of optimal study periods for next 24 hours
                    </div>
                </div>
            </div>

            <!-- Prediction Cards Container -->
            <div id="predictionContainer">
                <div class="prediction-message info">
                    <div class="message-icon">LOAD</div>
                    <div class="message-content">
                        <strong>Initializing Prediction Engine</strong>
                        <p>Loading historical data and analyzing patterns. Please wait...</p>
                    </div>
                </div>
            </div>

            <!-- Prediction Metadata -->
            <div id="predictionMetadata"></div>
        </div>

        <!-- Prediction Algorithm Explanation Card -->
        <div class="card" style="grid-column: 1 / -1; background: #f8f9fa;">
            <div style="padding: 10px;">
                <h3 style="color: #333; margin-bottom: 15px; font-size: 1.2em;">
                    How Predictions Work
                </h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                    <div>
                        <h4 style="color: #667eea; margin-bottom: 8px;">Data Collection</h4>
                        <p style="color: #666; font-size: 0.95em; line-height: 1.6;">
                            System analyzes 7 days of historical data including noise levels, heart rate,
                            and HRV patterns. Minimum 100 data points required for reliable predictions.
                        </p>
                    </div>
                    <div>
                        <h4 style="color: #667eea; margin-bottom: 8px;">Pattern Recognition</h4>
                        <p style="color: #666; font-size: 0.95em; line-height: 1.6;">
                            Algorithm identifies temporal patterns by grouping data into hourly time slots
                            for each day of the week, calculating flow state occurrence probability.
                        </p>
                    </div>
                    <div>
                        <h4 style="color: #667eea; margin-bottom: 8px;">Confidence Scoring</h4>
                        <p style="color: #666; font-size: 0.95em; line-height: 1.6;">
                            Each prediction receives a confidence score based on sample size, pattern
                            consistency, and probability strength. Higher scores indicate more reliable forecasts.
                        </p>
                    </div>
                    <div>
                        <h4 style="color: #667eea; margin-bottom: 8px;">Flow State Criteria</h4>
                        <p style="color: #666; font-size: 0.95em; line-height: 1.6;">
                            Optimal conditions: Noise below 55 dB, heart rate 60-80 BPM or high HRV
                            (RR interval above 700ms), indicating relaxed yet focused state.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>Smart Study Space Monitoring System v2.9</p>
            <p style="font-size: 0.9em; margin-top: 5px;">Real-time Monitoring + ThingSpeak Cloud Analytics</p>
        </footer>
    </div>

    <script>
        const ESP32_IP = window.location.hostname || '172.20.10.2';
        const REALTIME_API = `http://${ESP32_IP}/api/data`;
        const THINGSPEAK_CHANNEL_ID = 3158621;
        const READ_API_KEY = 'T1EFKX1JLOQNPO0C';
        const THINGSPEAK_API = `https://api.thingspeak.com/channels/${THINGSPEAK_CHANNEL_ID}/feeds.json?api_key=${READ_API_KEY}&results=8000`;

        const REALTIME_INTERVAL = 1000;
        const THINGSPEAK_INTERVAL = 60000;

        // Global Variables
        let tableDates = [];

        // Chart Init
        const historyCtx = document.getElementById('historyChart').getContext('2d');
        const historyChart = new Chart(historyCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'Noise (dB)', data: [], borderColor: '#4CAF50', backgroundColor: 'rgba(76, 175, 80, 0.1)', yAxisID: 'y', tension: 0.4 },
                    { label: 'Heart Rate (BPM)', data: [], borderColor: '#e91e63', backgroundColor: 'rgba(233, 30, 99, 0.1)', yAxisID: 'y1', tension: 0.4, spanGaps: true }
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                plugins: { legend: { position: 'top' } },
                scales: {
                    x: { display: true, title: { display: true, text: 'Time' } },
                    y: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Noise (dB)', color: '#4CAF50' }, min: 0, max: 80 },
                    y1: { type: 'linear', display: true, position: 'right', title: { display: true, text: 'Heart Rate (BPM)', color: '#e91e63' }, min: 0, max: 150, grid: { drawOnChartArea: false } }
                }
            }
        });

        // --- Helper Functions ---
        function getNoiseLevel(db) { if (db < 45) return 'Quiet'; if (db < 65) return 'Moderate'; return 'Noisy'; }
        function getNoiseColor(db) { if (db < 45) return '#4CAF50'; if (db < 65) return '#00BCD4'; return '#FFC107'; }
        

        // --- EVALUATION LOGIC ---
        function evaluateState(db, bpm, fingerDetected) {
            let env = "Normal", mind = "Neutral", overall = "Idle";
            if (db < 45) env = "Quiet"; else if (db < 65) env = "Normal"; else env = "Noisy";
            if (!fingerDetected || bpm === 0) mind = "--";
            else if (bpm < 65) mind = "Relaxed";
            else if (bpm < 100) mind = "Focused";
            else mind = "Excited";
            if (!fingerDetected) overall = "Standby";
            else if (env === "Noisy") overall = "Distracted";
            else if (env === "Quiet" && mind === "Focused") overall = "Flow State";
            else if (mind === "Excited") overall = "High Arousal";
            else if (mind === "Relaxed") overall = "Resting";
            else overall = "Learning";
            return { env, mind, overall };
        }

        function mapStateToCategory(detailedState) {
            switch (detailedState) {
                case 'Flow State': return 'Flow State';
                case 'Distracted': return 'Distracted';
                case 'Standby': return 'Standby';
                case 'Learning': case 'Resting': case 'High Arousal': return 'Normal Learning';
                default: return 'Standby';
            }
        }

        function getCategoryColor(category) {
            switch (category) {
                case 'Flow State': return '#4CAF50';
                case 'Normal Learning': return '#ff9800';
                case 'Distracted': return '#f44336';
                case 'Standby': return '#9e9e9e';
                default: return '#9e9e9e';
            }
        }

        // --- Suggestion Logic ---
        function updateSuggestionBox(assessment) {
            const card = document.getElementById('suggestionCard');
            const icon = document.getElementById('suggestionIcon');
            const title = document.getElementById('suggestionTitle');
            const text = document.getElementById('suggestionText');

            const env = assessment.env;
            const mind = assessment.mind;
            const isNoisy = (env === 'Noisy' || env === 'Loud');
            const isGoodState = (mind === 'Focused' || mind === 'Relaxed');
            const isBadState = (mind === 'Excited');
            const isStandby = (assessment.overall === 'Standby');

            card.style.background = '#fff'; card.style.borderColor = 'transparent';

            if (isStandby) {
                icon.textContent = 'üí§'; title.textContent = 'System Standby';
                text.textContent = 'No user detected. Place finger on sensor to begin.';
                card.style.background = '#f8f9fa';
            } else if (isNoisy && isGoodState) {
                icon.textContent = 'üéß'; title.textContent = 'Wear Headphones';
                text.textContent = 'It\'s noisy, but you are focused. Wear headphones to maintain your flow.';
                card.style.background = '#e3f2fd'; card.style.borderColor = '#2196F3';
            } else if (!isNoisy && isGoodState) {
                icon.textContent = 'üåü'; title.textContent = 'Excellent Condition';
                text.textContent = 'Optimal environment and mental state. Keep up the great work!';
                card.style.background = '#e8f5e9'; card.style.borderColor = '#4CAF50';
            } else if (!isNoisy && isBadState) {
                icon.textContent = '‚òï'; title.textContent = 'Take a Break';
                text.textContent = 'Environment is good, but you seem restless. Take a short break to adjust.';
                card.style.background = '#fff3e0'; card.style.borderColor = '#ff9800';
            } else if (isNoisy && isBadState) {
                icon.textContent = 'üö´'; title.textContent = 'Not Suitable for Study';
                text.textContent = 'Too noisy and you are distracted. Try moving to a quieter location.';
                card.style.background = '#ffebee'; card.style.borderColor = '#f44336';
            } else {
                icon.textContent = 'üìö'; title.textContent = 'Monitoring...';
                text.textContent = 'Tracking your study environment and vitals.';
            }
        }

        // --- UI Update (Modified to match ESP32 /api/data JSON) ---
        function updateRealtimeUI(data) {
            const noiseValue = parseFloat(data.noise) || 0;
            const bpm = parseInt(data.hr_avg) || 0;
            const irValue = parseInt(data.ir) || 0;
            const acValue = parseInt(data.ir_ac) || 0;

            const isFingerDetected = irValue > 50000;

            document.getElementById('noiseValue').textContent = noiseValue.toFixed(1);
            document.getElementById('noiseLevel').textContent = getNoiseLevel(noiseValue);
            document.getElementById('noiseValue').style.color = getNoiseColor(noiseValue);
            document.getElementById('bpmValue').textContent = bpm > 0 ? bpm : '--';
            document.getElementById('beatCount').textContent = data.beats || 0;
            document.getElementById('p2pValue').textContent = data.p2p || '--'; // Use ESP32's p2p value

            const fingerStatusText = isFingerDetected ? 'Detected' : 'No Finger';
            document.getElementById('fingerStatus').textContent = fingerStatusText;
            document.getElementById('fingerStatus').style.color = isFingerDetected ? '#4CAF50' : '#999';

            const assessment = evaluateState(noiseValue, bpm, isFingerDetected);
            document.getElementById('overallState').textContent = assessment.overall;
            document.getElementById('envState').textContent = assessment.env;
            document.getElementById('mindState').textContent = assessment.mind;
            const category = mapStateToCategory(assessment.overall);
            document.getElementById('overallState').style.color = getCategoryColor(category);

            updateSuggestionBox(assessment);

            if (isFingerDetected && acValue < 50) {
                const quality = getSignalQuality(acValue);
                const signalMessage = document.getElementById('signalMessage');
                document.getElementById('signalMessageText').textContent = quality.message;
                signalMessage.style.display = 'flex';
                signalMessage.className = acValue > 20 ? 'status-message warning' : 'status-message error';
            } else {
                document.getElementById('signalMessage').style.display = 'none';
            }

            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString('en-US');
        }

        // --- INITIALIZATION ---
        function initEmptyTable() {
            const now = new Date();
            tableDates = [];
            for (let i = 2; i >= 0; i--) {
                const d = new Date(now);
                d.setDate(now.getDate() - i);
                tableDates.push(d.toISOString().split('T')[0]);
                const headerEl = document.getElementById(`date-header-${2-i}`);
                if (headerEl) {
                    if (i === 0) headerEl.textContent = "Today";
                    else if (i === 1) headerEl.textContent = "Yesterday";
                    else headerEl.textContent = d.toLocaleDateString('en-US', {month:'short', day:'numeric'});
                }
            }
            const tbody = document.getElementById('historyTableBody');
            tbody.innerHTML = '';
            const timeSlots = [
                "00:00 - 03:00", "03:00 - 06:00", "06:00 - 09:00", "09:00 - 12:00",
                "12:00 - 15:00", "15:00 - 18:00", "18:00 - 21:00", "21:00 - 24:00"
            ];
            timeSlots.forEach((slotLabel, slotIndex) => {
                const tr = document.createElement('tr');
                tr.id = `row-${slotIndex}`;
                const tdTime = document.createElement('td');
                tdTime.textContent = slotLabel;
                tdTime.style.fontWeight = 'bold'; tdTime.style.color = '#555';
                tr.appendChild(tdTime);
                for(let c = 0; c < 3; c++) {
                    const td = document.createElement('td');
                    td.id = `cell-${c}-${slotIndex}`;
                    td.className = 'empty-slot';
                    td.textContent = '-';
                    tr.appendChild(td);
                }
                tbody.appendChild(tr);
            });
        }

        function processHistoryData(feeds) {
            const gridData = {};
            tableDates.forEach(dateStr => {
                gridData[dateStr] = Array(8).fill(null).map(() => ({
                    counts: { 'Flow State': 0, 'Normal Learning': 0, 'Distracted': 0, 'Standby': 0 }
                }));
            });
            feeds.forEach(feed => {
                const feedDate = new Date(feed.created_at);
                const dateStr = feedDate.toISOString().split('T')[0];
                if (gridData[dateStr]) {
                    const hour = feedDate.getHours();
                    const slotIndex = Math.floor(hour / 3);
                    const noise = parseFloat(feed.field2) || 0;
                    const bpm = parseInt(feed.field3) || 0;
                    const isFingerDetected = (bpm > 40 && bpm < 200);
                    const state = evaluateState(noise, bpm, isFingerDetected);
                    const category = mapStateToCategory(state.overall);
                    gridData[dateStr][slotIndex].counts[category]++;
                }
            });
            tableDates.forEach((dateStr, colIndex) => {
                for(let slotIndex = 0; slotIndex < 8; slotIndex++) {
                    const slotStats = gridData[dateStr][slotIndex];
                    const cell = document.getElementById(`cell-${colIndex}-${slotIndex}`);
                    if(cell) {
                        let maxCount = 0; let dominantCategory = 'Standby'; let totalCount = 0;
                        for (const [cat, count] of Object.entries(slotStats.counts)) {
                            totalCount += count;
                            if (count > maxCount) { maxCount = count; dominantCategory = cat; }
                        }
                        cell.innerHTML = ''; cell.className = '';
                        if (totalCount > 0) {
                            const badge = document.createElement('span');
                            badge.className = 'status-badge';
                            badge.style.backgroundColor = getCategoryColor(dominantCategory);
                            badge.textContent = dominantCategory;
                            cell.appendChild(badge);
                        } else {
                            cell.className = 'empty-slot'; cell.textContent = '-';
                        }
                    }
                }
            });
        }

        // --- API Calls ---
        function updateConnectionStatus(isConnected) {
            const d = document.getElementById('connectionStatus');
            const t = document.getElementById('connectionText');
            if (isConnected) { d.className = 'status-dot online'; t.textContent = 'ESP32 Connected'; }
            else { d.className = 'status-dot offline'; t.textContent = 'Disconnected'; }
        }

        async function fetchRealtimeData() {
            try {
                const res = await fetch(REALTIME_API);
                if (!res.ok) throw new Error('Err');
                const data = await res.json();
                updateRealtimeUI(data);
                updateConnectionStatus(true);
            } catch (e) { console.error(e); updateConnectionStatus(false); }
        }

async function fetchThingSpeakData() {
    try {
        const res = await fetch(THINGSPEAK_API);
        if (!res.ok) throw new Error('Err');
        const data = await res.json();
        if (data.feeds) {
            const analysis = analyzeThingSpeakData(data.feeds);
            if(analysis) {
                 document.getElementById('avgNoise').textContent = analysis.avgNoise + ' dB';
                 document.getElementById('avgBPM').textContent = analysis.avgBPM + ' BPM';
                 document.getElementById('bpmRange').textContent = analysis.minBPM > 0 ? `${analysis.minBPM}-${analysis.maxBPM}` : '--';
                 document.getElementById('noisyPercent').textContent = analysis.noisyPercent + '%';
                 document.getElementById('dataPoints').textContent = analysis.dataPoints;
                 document.getElementById('envQuality').textContent = analysis.envQuality;
            }
            const recent = data.feeds.slice(-50);

            historyChart.data.labels = recent.map((f, index) => {
                if (index % 5 === 0) {
                    return new Date(f.created_at).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                } else {
                    return '';
                }
            });

            historyChart.data.datasets[0].data = recent.map(f => parseFloat(f.field2)||0);
            historyChart.data.datasets[1].data = recent.map(f => {
                const bpm = parseInt(f.field5) || 0;
                if (bpm > 150 || bpm === 0) {
                    return null;
                }
                return bpm;
            });

            historyChart.update();
            processHistoryData(data.feeds);
            }
        } catch (e) { console.error(e); }
    }

        function analyzeThingSpeakData(feeds) {
            if (!feeds || feeds.length === 0) return null;
            let tn=0, tb=0, vb=0, mx=0, mn=999, nc=0;
            feeds.forEach(f => {
                const n = parseFloat(f.field2); const b = parseInt(f.field5);
                if (!isNaN(n)) { tn+=n; if(n>60) nc++; }
                if (b>60 && b<200) { tb+=b; vb++; if(b>mx) mx=b; if(b<mn) mn=b; }
            });
            const an = tn/feeds.length; const ab = vb>0?Math.round(tb/vb):0;
            let eq = 'Excellent'; if(an>60) eq='Poor'; else if(an>50) eq='Average'; else if(an>40) eq='Good';
            return { avgNoise: an.toFixed(1), avgBPM: ab, minBPM: mn===999?0:mn, maxBPM: mx, noisyPercent: Math.round((nc/feeds.length)*100), dataPoints: feeds.length, envQuality: eq };
        }

        // --- INIT ---
        initEmptyTable();
        fetchRealtimeData();
        fetchThingSpeakData();
        setInterval(fetchRealtimeData, REALTIME_INTERVAL);
        setInterval(fetchThingSpeakData, THINGSPEAK_INTERVAL);

        // ========== PREDICTION MODULE ==========
        const PREDICTION_CONFIG = {
            PREDICTION_WINDOW: 24,
            HISTORICAL_DAYS: 7,
            MIN_DATA_POINTS: 100,
            FLOW_STATE_THRESHOLD: 0.3,
            TOP_PREDICTIONS: 5,
            UPDATE_INTERVAL: 3600000
        };

        const STATE_THRESHOLDS = {
            NOISE_THRESHOLD: 55.0,
            BPM_LOW: 55,
            BPM_HIGH: 100,
            HRV_THRESHOLD: 50,
            BPM_MIN_VALID: 40,
            BPM_MAX_VALID: 200
        };

        let predictionData = {
            predictions: [],
            lastUpdate: null,
            confidence: 0,
            dataQuality: 'insufficient'
        };

        async function runPredictionAnalysis() {
            console.log('[Prediction] Starting flow state prediction analysis...');

            try {
                const historicalData = await fetchPredictionHistoricalData();

                if (!historicalData || historicalData.length < PREDICTION_CONFIG.MIN_DATA_POINTS) {
                    console.log('[Prediction] Insufficient data. Need at least',
                               PREDICTION_CONFIG.MIN_DATA_POINTS, 'points. Current:',
                               historicalData ? historicalData.length : 0);
                    updatePredictionUINoData(historicalData ? historicalData.length : 0);
                    return null;
                }

                console.log('[Prediction] Processing', historicalData.length, 'data points');

                const patterns = analyzeTemporalPatterns(historicalData);
                const predictions = generateFlowStatePredictions(patterns);
                const overallConfidence = calculateOverallConfidence(predictions, historicalData.length);

                predictionData.predictions = predictions;
                predictionData.lastUpdate = new Date();
                predictionData.confidence = overallConfidence;
                predictionData.dataQuality = assessDataQuality(historicalData.length);

                updatePredictionUI(predictions, overallConfidence);

                console.log('[Prediction] Analysis complete. Found', predictions.length, 'potential flow states');

                return predictions;

            } catch (error) {
                console.error('[Prediction] Error during analysis:', error);
                updatePredictionUIError();
                return null;
            }
        }

        async function fetchPredictionHistoricalData() {
            const daysAgo = PREDICTION_CONFIG.HISTORICAL_DAYS;
            const estimatedResults = daysAgo * 24 * 60 / 5;

            try {
                const url = `${THINGSPEAK_API}&results=${estimatedResults}`;
                const response = await fetch(url);

                if (!response.ok) {
                    throw new Error('Failed to fetch data from ThingSpeak');
                }

                const data = await response.json();

                if (!data.feeds || data.feeds.length === 0) {
                    return null;
                }

                const cleanData = data.feeds.map(feed => {
                    const timestamp = new Date(feed.created_at);
                    const noise = parseFloat(feed.field2) || 0;
                    const rrInterval = parseFloat(feed.field3) || 0;
                    const bpmAvg = parseInt(feed.field5) || 0;
                    const bpmRealtime = parseInt(feed.field6) || 0;

                    const bpm = bpmAvg > 0 ? bpmAvg : bpmRealtime;
                    const state = classifyStateForPrediction(noise, bpm, rrInterval);

                    return {
                        timestamp: timestamp,
                        hour: timestamp.getHours(),
                        dayOfWeek: timestamp.getDay(),
                        date: timestamp.toISOString().split('T')[0],
                        noise: noise,
                        bpm: bpm,
                        rrInterval: rrInterval,
                        state: state,
                        isFlowState: state === 'Flow State'
                    };
                }).filter(d => d.bpm >= STATE_THRESHOLDS.BPM_MIN_VALID &&
                              d.bpm <= STATE_THRESHOLDS.BPM_MAX_VALID);

                console.log('[Prediction] Cleaned data points:', cleanData.length);

                return cleanData;

            } catch (error) {
                console.error('[Prediction] Data fetch error:', error);
                return null;
            }
        }

        function classifyStateForPrediction(noise, bpm, rrInterval) {
            if (bpm < STATE_THRESHOLDS.BPM_MIN_VALID || bpm > STATE_THRESHOLDS.BPM_MAX_VALID) {
                return 'Standby';
            }

            const isQuiet = noise < STATE_THRESHOLDS.NOISE_THRESHOLD;
            const hasGoodHRV = rrInterval > STATE_THRESHOLDS.HRV_THRESHOLD;
            const hasOptimalBPM = (bpm >= STATE_THRESHOLDS.BPM_LOW && bpm <= STATE_THRESHOLDS.BPM_HIGH);
            const isGoodPhysio = hasGoodHRV || hasOptimalBPM;

            if (isQuiet && isGoodPhysio) {
                return 'Flow State';
            } else if (!isQuiet && isGoodPhysio) {
                return 'Normal Learning';
            } else if (isQuiet && !isGoodPhysio) {
                return 'Standby';
            } else {
                return 'Distracted';
            }
        }

        function analyzeTemporalPatterns(data) {
            const hourlyPatterns = {};

            for (let day = 0; day < 7; day++) {
                for (let hour = 0; hour < 24; hour++) {
                    const key = `${day}-${hour}`;
                    hourlyPatterns[key] = {
                        day: day,
                        hour: hour,
                        flowStateCount: 0,
                        totalCount: 0,
                        noiseSum: 0,
                        bpmSum: 0,
                        rrIntervalSum: 0,
                        samples: []
                    };
                }
            }

            data.forEach(entry => {
                const key = `${entry.dayOfWeek}-${entry.hour}`;

                if (hourlyPatterns[key]) {
                    hourlyPatterns[key].totalCount++;
                    hourlyPatterns[key].noiseSum += entry.noise;
                    hourlyPatterns[key].bpmSum += entry.bpm;
                    hourlyPatterns[key].rrIntervalSum += entry.rrInterval;

                    if (entry.isFlowState) {
                        hourlyPatterns[key].flowStateCount++;
                    }

                    hourlyPatterns[key].samples.push({
                        timestamp: entry.timestamp,
                        state: entry.state
                    });
                }
            });

            Object.keys(hourlyPatterns).forEach(key => {
                const pattern = hourlyPatterns[key];

                if (pattern.totalCount > 0) {
                    pattern.avgNoise = pattern.noiseSum / pattern.totalCount;
                    pattern.avgBPM = pattern.bpmSum / pattern.totalCount;
                    pattern.avgRRInterval = pattern.rrIntervalSum / pattern.totalCount;
                    pattern.probability = pattern.flowStateCount / pattern.totalCount;

                    const variance = pattern.samples.reduce((sum, sample) => {
                        const isFlow = sample.state === 'Flow State' ? 1 : 0;
                        return sum + Math.pow(isFlow - pattern.probability, 2);
                    }, 0) / pattern.totalCount;

                    pattern.consistency = 1 - Math.sqrt(variance);
                } else {
                    pattern.avgNoise = 0;
                    pattern.avgBPM = 0;
                    pattern.avgRRInterval = 0;
                    pattern.probability = 0;
                    pattern.consistency = 0;
                }
            });

            console.log('[Prediction] Pattern analysis complete for', Object.keys(hourlyPatterns).length, 'time slots');

            return hourlyPatterns;
        }

        function generateFlowStatePredictions(patterns) {
            const now = new Date();
            const predictions = [];

            for (let i = 1; i <= PREDICTION_CONFIG.PREDICTION_WINDOW; i++) {
                const futureTime = new Date(now.getTime() + i * 60 * 60 * 1000);
                const futureDay = futureTime.getDay();
                const futureHour = futureTime.getHours();

                const key = `${futureDay}-${futureHour}`;
                const pattern = patterns[key];

                if (pattern && pattern.probability >= PREDICTION_CONFIG.FLOW_STATE_THRESHOLD) {
                    const confidence = calculatePredictionConfidence(pattern);

                    predictions.push({
                        time: futureTime,
                        hour: futureHour,
                        dayOfWeek: futureDay,
                        probability: pattern.probability,
                        confidence: confidence,
                        expectedNoise: pattern.avgNoise,
                        expectedBPM: pattern.avgBPM,
                        expectedRRInterval: pattern.avgRRInterval,
                        sampleSize: pattern.totalCount,
                        consistency: pattern.consistency,
                        hoursFromNow: i
                    });
                }
            }

            predictions.sort((a, b) => {
                const scoreA = a.probability * (a.confidence / 100);
                const scoreB = b.probability * (b.confidence / 100);
                return scoreB - scoreA;
            });

            return predictions.slice(0, PREDICTION_CONFIG.TOP_PREDICTIONS);
        }

        function calculatePredictionConfidence(pattern) {
            const MIN_SAMPLES_FOR_CONFIDENCE = 10;
            const IDEAL_SAMPLES = 50;

            const sampleFactor = Math.min(pattern.totalCount / IDEAL_SAMPLES, 1.0);
            const consistencyFactor = pattern.consistency;
            const probabilityFactor = pattern.probability;

            if (pattern.totalCount < MIN_SAMPLES_FOR_CONFIDENCE) {
                return 0;
            }

            const confidence = (
                sampleFactor * 0.4 +
                consistencyFactor * 0.3 +
                probabilityFactor * 0.3
            ) * 100;

            return Math.round(confidence);
        }

        function calculateOverallConfidence(predictions, dataPoints) {
            if (predictions.length === 0) {
                return 0;
            }

            const avgConfidence = predictions.reduce((sum, p) => sum + p.confidence, 0) / predictions.length;
            const dataFactor = Math.min(dataPoints / 500, 1.0);

            return Math.round(avgConfidence * 0.7 + dataFactor * 30);
        }

        function assessDataQuality(dataPoints) {
            if (dataPoints < 100) return 'insufficient';
            if (dataPoints < 300) return 'low';
            if (dataPoints < 800) return 'moderate';
            if (dataPoints < 1500) return 'good';
            return 'excellent';
        }

        function updatePredictionUI(predictions, overallConfidence) {
            const container = document.getElementById('predictionContainer');
            if (!container) return;

            container.innerHTML = '';

            if (!predictions || predictions.length === 0) {
                container.innerHTML = `
                    <div class="prediction-message info">
                        <div class="message-icon">INFO</div>
                        <div class="message-content">
                            <strong>No High-Probability Flow States Detected</strong>
                            <p>Based on historical patterns, no time slots in the next 24 hours show strong likelihood of flow state conditions.</p>
                        </div>
                    </div>
                `;
                return;
            }

            predictions.forEach((pred, index) => {
                const card = createPredictionCard(pred, index);
                container.appendChild(card);
            });

            updatePredictionMetadata(overallConfidence);
        }

        function createPredictionCard(prediction, rank) {
            const card = document.createElement('div');
            card.className = 'prediction-card';

            const qualityClass = getQualityClass(prediction.confidence);

            card.innerHTML = `
                <div class="prediction-header">
                    <div class="prediction-rank">Rank ${rank + 1}</div>
                    <div class="prediction-quality ${qualityClass}">${prediction.confidence}% Confidence</div>
                </div>

                <div class="prediction-time-display">
                    <div class="time-value">${prediction.time.toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: true
                    })}</div>
                    <div class="time-date">${prediction.time.toLocaleDateString('en-US', {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric'
                    })}</div>
                    <div class="time-relative">${prediction.hoursFromNow} hours from now</div>
                </div>

                <div class="prediction-metrics-grid">
                    <div class="metric-cell">
                        <div class="metric-label">Probability</div>
                        <div class="metric-value">${(prediction.probability * 100).toFixed(0)}%</div>
                    </div>
                    <div class="metric-cell">
                        <div class="metric-label">Consistency</div>
                        <div class="metric-value">${(prediction.consistency * 100).toFixed(0)}%</div>
                    </div>
                    <div class="metric-cell">
                        <div class="metric-label">Sample</div>
                        <div class="metric-value">${prediction.sampleSize}</div>
                    </div>
                </div>

                <div class="prediction-expected">
                    <div class="expected-title">Expected Conditions:</div>
                    <div class="expected-values">
                        Noise: ${prediction.expectedNoise.toFixed(1)} dB |
                        Heart Rate: ${prediction.expectedBPM.toFixed(0)} BPM
                    </div>
                </div>
            `;

            return card;
        }

        function getQualityClass(confidence) {
            if (confidence >= 70) return 'quality-high';
            if (confidence >= 50) return 'quality-medium';
            return 'quality-low';
        }

        function updatePredictionMetadata(overallConfidence) {
            const metadataElement = document.getElementById('predictionMetadata');
            if (!metadataElement) return;

            const lastUpdateTime = predictionData.lastUpdate.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit'
            });

            const qualityLabel = predictionData.dataQuality.charAt(0).toUpperCase() +
                                predictionData.dataQuality.slice(1);

            metadataElement.innerHTML = `
                <div class="metadata-item">
                    <span class="metadata-label">Last Updated:</span>
                    <span class="metadata-value">${lastUpdateTime}</span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">Overall Confidence:</span>
                    <span class="metadata-value">${overallConfidence}%</span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">Data Quality:</span>
                    <span class="metadata-value">${qualityLabel}</span>
                </div>
            `;
        }

        function updatePredictionUINoData(currentDataPoints) {
            const container = document.getElementById('predictionContainer');
            if (!container) return;

            const needed = PREDICTION_CONFIG.MIN_DATA_POINTS - currentDataPoints;
            const percentage = Math.round((currentDataPoints / PREDICTION_CONFIG.MIN_DATA_POINTS) * 100);

            container.innerHTML = `
                <div class="prediction-message info">
                    <div class="message-icon">DATA</div>
                    <div class="message-content">
                        <strong>Collecting Historical Data</strong>
                        <p>Prediction requires at least ${PREDICTION_CONFIG.MIN_DATA_POINTS} data points.
                        Current progress: ${currentDataPoints} / ${PREDICTION_CONFIG.MIN_DATA_POINTS} (${percentage}%)</p>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${percentage}%"></div>
                        </div>
                        <p class="progress-note">Approximately ${needed} more readings needed. Check back in ${Math.ceil(needed / 12)} hours.</p>
                    </div>
                </div>
            `;

            const metadataElement = document.getElementById('predictionMetadata');
            if (metadataElement) {
                metadataElement.innerHTML = `
                    <div class="metadata-item">
                        <span class="metadata-label">Status:</span>
                        <span class="metadata-value">Awaiting Sufficient Data</span>
                    </div>
                `;
            }
        }

        function updatePredictionUIError() {
            const container = document.getElementById('predictionContainer');
            if (!container) return;

            container.innerHTML = `
                <div class="prediction-message error">
                    <div class="message-icon">ERROR</div>
                    <div class="message-content">
                        <strong>Prediction Error</strong>
                        <p>Unable to generate predictions. Please check your connection and try again later.</p>
                    </div>
                </div>
            `;
        }

        function initializePredictionModule() {
            console.log('[Prediction] Initializing prediction module...');
            runPredictionAnalysis();
            setInterval(runPredictionAnalysis, PREDICTION_CONFIG.UPDATE_INTERVAL);
            console.log('[Prediction] Module initialized. Updates every',
                        PREDICTION_CONFIG.UPDATE_INTERVAL / 1000 / 60, 'minutes');
        }

        setTimeout(initializePredictionModule, 2000);
    </script>
</body>
</html>